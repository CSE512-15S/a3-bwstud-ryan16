<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>A3</title>

  <style>
    html, body { width: 100%; height: 100%; margin: 0; } 
   
    .pt {
      fill: red;
    }

    #vis {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      height: 100%;
      width: 100%;
      background-color: black;
    }

    .orbit {
      fill: none;
      stroke: rgba(0, 255, 255, 0.25);
    }

    .orbit.selected {
      /* stroke: rgba(127, 255, 127, 0.25); */
      stroke-dasharray: 2,2;
    }

    .sun {
      fill: yellow;
    }

    .distance-axis {
      opacity: 0.25;
    }

    .distance-axis text {
      fill: white;
    }

    .distance-axis .tick line {
      stroke: white;
      stroke-width: 1px;
    }

    .distance-axis .domain { stroke: white; fill: none; }
  </style>
</head>
<body>
  <svg id="vis"><text x=0 y=20 fill=white id="current">Current</text></svg>
  <script src="lib/d3.min.js"></script>
  <script src="lib/timbre.js"></script>
  <script src="data.js"></script>
  <script src="sound.js"></script>
  <script>
    var currentView = sun.satellites[4];
    window.onload = function() {
      var RECT, WIDTH, HEIGHT, zoom;

      var svg = d3.select("#vis")
        .append("g") // use a group to translate our coordinates to the center
          .attr("class", "container")

      // resize the visualization
      window.addEventListener('resize', handleResize);
      function handleResize() {
        RECT = document.getElementById("vis").getBoundingClientRect();
        WIDTH = RECT.right - RECT.left;
        HEIGHT = RECT.bottom - RECT.top; 
        d3.select(".container")
          .attr("transform", "translate(" + WIDTH/2 + "," + HEIGHT/2 + ")");
      }
      handleResize();
      zoom = 0.9*Math.min(WIDTH/2, HEIGHT/2);

      var ap = function(d) { return d.ap; };

      var r = d3.scale.linear()
        .domain([0, currentView.r])
        .range([1, 30]);

      var dist = d3.scale.linear()
      
      svg.append("circle")
        .datum(currentView)
        .attr("fill", function(d) { return d.color||"red"; })
        .attr("r", function(d) { return r(d.r); })
        .attr("cx", 0)
        .attr("cy", 0)

      render();

      document.addEventListener("DOMMouseScroll", handleWheel);
      document.addEventListener("mousewheel", handleWheel);
      function handleWheel(e) {
        var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail)));
        if (delta < 0) {
          zoom /= 1.1;
        } else {
          zoom *= 1.1;
        }
        render();
        handleMouseMove(currentMouseEvent);
        e.preventDefault();
      }

      var minBody;
      var currentMouseEvent;
      document.addEventListener("mousemove", handleMouseMove);
      function handleMouseMove(e) {
        currentMouseEvent = e;
        var x = e.layerX - WIDTH/2,
            y = e.layerY - HEIGHT/2,
            r = Math.sqrt(x*x + y*y);
        var mouseDist = dist.invert(r);
        var min;
        if (mouseDist < currentView.r) {
          minBody = currentView.name;
        } else currentView.satellites.forEach(function(body) {
          if (min == null) {
            min = Math.abs(body.ap - mouseDist);
            minBody = body.name;
          } else if (Math.abs(body.ap - mouseDist) < min) {
            min = Math.abs(body.ap - mouseDist);
            minBody = body.name;
          }
        });
        d3.select("#current").html(minBody);
        d3.selectAll(".orbit").attr("class", function(d) { return d.name === minBody ? "orbit selected" : "orbit"; })
      }

      function render() {
       dist.domain([currentView.r, d3.max(currentView.satellites, ap)])
           .range([r(currentView.r), zoom]);

        var pts = svg.selectAll(".pt")
          .data(currentView.satellites)

        // orbit lines
        function orbit(d) {
          d.attr("r", function(d) { return dist(d.ap); })
        }
        var orbits = svg.selectAll(".orbit").data(currentView.satellites);
        orbits.call(orbit);
        orbits.enter()
          .append("circle")
          .attr("class", "orbit")
          .attr("cx", 0)
          .attr("cy", 0)
          .call(orbit);
        orbits.exit().remove();

        // bodies
        function body(d) {
          d.attr("cx", function(d) { return Math.cos(d.period)*dist(d.ap); })
           .attr("cy", function(d) { return -Math.sin(d.period)*dist(d.ap); })
        }
        
        pts.call(body);
        pts.enter().append("circle")
           .attr("r", function(d) { return r(d.r); })
           .attr("class", "pt")
           .attr("style", function(d) { return "fill:" + (d.color || "red"); })
           .call(body);
        pts.exit().remove()
      }

      requestAnimationFrame(function frame() {
        // rendering
        
        d3.select(".pt")
        requestAnimationFrame(frame);
      });

    };
  </script>
</body>
</html>
